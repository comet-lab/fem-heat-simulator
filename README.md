# HeatSimulation


This code base models the thermal response of tissue to laser irradiation using the finite element method (FEM).
Our model assumes that the tissue can be represented as a cuboid. Each surface on the cuboid can have one of 
three boundary conditions: a heat sink, a flux boundary, or a convection boundary. 
For modeling details, see the reference below [1]. 

The main FEM modeling is performed in C++ using the Eigen Library. The file 'main.cpp' provides an example of 
how to initialize and run an FEM_Simulation object, which is defined in 'FEM_Simulation.h'. If you would like to run the
simulations on a GPU, use the GPUTimeIntegration class. Additionally, the simulation can be called and run 
from MATLAB using the MEX file executable that gets generated 

## Dependencies

Eigen3 Version 3.4 must be installed.

### For GPU Acceleration

CudaToolkit Version 12.8 must be installed 

AMGX must be installed. 

## Building the project

To build the project run the following commands:

``mkdir build``\
``cd build``\
``cmake -DCMAKE_BUILD_TYPE=Release ..``\
``cmake --build .``

This copmile a library that can be included in other projects. Additionally, it will compile a file called main.exe which serves as a test script. 

### cmake arguments

- ``CMAKE_BUILD_TYPE``: can be ``Release`` (which is necessary to build MEX files) or ``Debug``. 
- ``BUILD_TESTING``: can be ``ON`` (Default) or ``OFF``. Determines if test executables are created (FEM_Unit_Tests.exe and GPUSolver_Unit_Tests.exe)
- ``BUILD_FEM_MEX``: can be ``ON`` (Default) or ``OFF``. Determines if the MEX files (MEX_Heat_Simulation.mex*64 and MEX_Heat_Simulation_MultiStep.mex*64) are compiled
- ``USE_CUDA``: can be ``ON`` or ``OFF`` (Default). Determines whether to compile the code necessary for GPU acceleration. 
- ``AMGX_ROOT``: The root location of the AMGX library files. Default is /usr/local/amgx. Necessary if ``USE_CUDA`` is ``ON``.

### Library Install
The library name is HeatSimulation. If you would like to install the library so it can be found using
``find-package(HeatSimulation)`` then run the following command:

``cmake --install .``

## Description of the simulation class

The simulation class is declared in FEM_Simulator.h and defined in FEM_Simulator.cpp. 
See 'main.cpp' for an example of how to initialize and run the simulator. 
The simulator will discretize the mesh into elements, create the global M, K, and F matrices, and 
perform the time integration. Note that the simulator uses a left handed coordinate system. The origin is located
at the center of the top surface of the cuboid. Assuming a planar (2D) view of the tissue with the origin at the top of the page,
the z-axis points down the page, the x-axis points out of the page, and the y-axis points to the right. 


To construct a basic simulation object, you need the following information

- ``Temp``: the initial temperature at every node in the mesh [ $^o\text{C}$ ],
- ``tissueSize``: the tissue size along the x, y, and z axes [cm]
- ``TC``: the thermal conductivity of the tissue [ $\frac{\text{W}}{\text{cm}~^o\text{C}}$ ]
- ``VHC``: the volumetric heat capacity of the tissue [ $\frac{\text{J}}{\text{cm}^3~^o\text{C}}$ ]
- ``MUA``: the absorption coefficient of the laser [ $\text{cm}^{-1}$ ]
- ``HTC``: the heat transfer coefficient [ $\frac{\text{W}}{\text{cm}^2~^o\text{C}}$ ]
- ``Nn1d``: the number of nodes along one dimension of an element. For linear basis functions use 2. For quadratic basis functions use 3. Some functionality may not be available with quadratic basis functions.

By default the, simulator assumes all 6 faces of the cuboid are dirichlet boundaries (i.e. heat sinks). To change the boundary conditions 
use the function 'FEM_Simulator::setBoundaryConditions(BC)'. The possible options are

- 0: Heat Sink (the initial temperature set at the boundary will be held constant)
- 1: Flux Boundary (for a flux boundary, the ``flux`` attribute needs to be set)
- 2: Convection Boundary (for a Convection boundary, the ``ambientTemp`` attribute needs to be set)

To set the fluence rate of the laser, use the method ``FEM_Simulator::setFluenceRate()``. The fluence rate at each node
can be passed in directly. It can also be generated by the simulator if the laser pose, laser power, beam waist,
and laser wavelength are passed in instead. 
If the absorption coefficient is very high, the fluence rate may need a large number of elements along the z-direction to 
approximate it. In this case, it may be appropriate to use the ``layerHeight`` and ``elemsInLayer`` attributes. 
These attributes allow the user to create a mesh with elements of varying length in the z-axis. 

- ``layerHeight``: the tissue size [cm] that corresponds to the first mesh layer
- ``elemsInLayer``: the number of elements that will be used to to represent the first layer

The remaining elements in the mesh will be used to represent the remaining block of tissue. 

Other parameters that can be adjusted include the type of time integration. By default, we use a step size of 0.01 seconds. 
This can be adjusted by setting the attribute ``deltaT``. 
By default we use the Crank-Nicolson which sets the attribute ``alpha`` equal to 0.5. 
If backward Euler is desired, change ``alpha`` to 1. For forwad Euler, change ``alpha`` to 0. Note that there are no checks for
stability when using Forward Euler. If your time step is too large the system may be unstable. 

Additionally print statements can be controlled with the, ``silentMode`` attribute. If you would like to enable multi-threading,
simply call ``Eigen::SetNbThreads()`` before running the simulator. 

### Running the Simulator on CPU
After all appropriate conditions have been set for the object, we can initialize and run the model. 
To initialize the model, call the function ``FEM_Simulator::initializeModel()``. This will perform the spatial discretization and get the system ready
to perform the time integration. Then call either ``FEM_Simulator::singleStep()`` or ``FEM_Simulator::multiStep()`` to simulate the time stepping. 
If there are no changes to the tissue geometry, number of nodes, or boundary conditions the matrices do not need to be rebuilt
between subsequent calls to ``FEM_Simulator::singleStep()`` or ``FEM_Simulator::multiStep()``. However, if one of those items changes, 
``FEM_Simulator::initializeModel()`` will need to be rerun.

### Using GPU Acceleration
After initializing the ``FEM_Simulator`` object, call ``FEM_Simulator::buildMatrices()`` to initialize the component matrices necessary to perform the time integration. Then , create an instance of ``GPUTimeIntegrator`` and call ``GPUTimeIntegrator::setModel(FEM_Simulation*)``. This will upload the necessary matrices on the GPU. From here simply call ``GPUTimeIntegrator::initializeWithModel()`` to initialize the ``d`` and ``v`` vectors for time stepping. To perform a step then call ``GPUTimeIntegrator::singleStepWithUpdate()``. Note that ``initializeWithModel()`` only needs to be called if the time step ``deltaT`` or ``alpha`` change. Similarly, if there are any changes to the tissue geometry, number ofnodes, or boundary conditions, the matrices need to be rebuilt and ``setModel`` needs to be called again. 

## MEX Usage
The mex file can be called in MATALB as long as it is on the MATLAB Path. 
Example usage can be found in the folder MexTesting/MexFileTest.m. The mex file controls parellelization by
setting the useAllCPUs variable. 

``[Tpred,sensorTemps] = MEX_Heat_Simulation(T0,fluenceRate,tissueSize',deltaT,...
        deltaT,tissueProperties,BC,flux,ambientTemp,sensorPositions,layerInfo,...
        useAllCPUs,useGPU,alpha,silentMode,Nn1d,createMatrices);``

Alternatively, you can use the multi-step mex file which takes in a time series of inputs. This allows you to reduce the number
of mex calls if you are simlating a multi-step process with changing inputs. 

``[TpredMulti,sensorTempsMulti] = MEX_Heat_Simulation_MultiStep(T0,tissueSize',...
    tissueProperties,BC,flux,ambientTemp,sensorPositions,w0,time,...
    laserPose,laserPower,layerInfo,useAllCPUs,useGPU,alpha,...
    silentMode,Nn1d);``


# References
[1] N. E. Pacheco, K. Zhang, A. S. Reyes, C. J. Pacheco, L. Burstein,
and L. Fichera, ''Towards a physics engine to simulate robotic laser
surgery: Finite element modeling of thermal laser-tissue interactions'',
International Symposium on Medical Robotics, 2025, [In Press] Available:
https://arxiv.org/abs/2411.14249.
